\section{Related Work}\label{sec:related-work}
\para{High level SDN Program Compilers:} Multiple systems that allow programmers to write SDN programs in high level languages and then compile such programs to flow table pipelines have been proposed over the last several years. Such systems are related to our work in that they examine the transformation of policy programs into switch flow tables. We group these systems into two categories: \textit{tier-less} and \textit{split-level}.

\textit{Tier-less} systems (\eg\ SNAP~\cite{SNAP}, FML~\cite{fml}, FlowLog~\cite{flowlog},  Maple~\cite{maple}), require programmers to specify forwarding behaviors as packet handling functions which are then used by the SDN controller to configure and update network state. Such systems pioneer our pipeline capacity theorem's notion of a \textit{program function} and are able to compile such functions to single pipelines. These systems, however, are unable to verify that submitted functions can be written to a given pipeline without physically carrying out the time consuming process of compilation, and cannot write programs to multi-pipeline networks.

\textit{Split-level} systems such as the Frentic family (\eg\ Frenetic~\cite{frenetic}, Pyretic~\cite{pyretic}) provide a two tiered programming model in which controller programs specify events of interest and then respond to these events when they occur by calculating new network policies. Again, such systems cannot verify that a given controller program's output can be written to the controller's switches' pipelines, although this paradigm falls outside of our pipeline capacity theorem's model as well.

\para{Pipeline specification languages:} There are some superficial similarities between pipeline specification languages (\eg\ P4~\cite{P4} P5~\cite{Lee2017P5}, PISCES~\cite{PISCES}, Concurrent NetCore~\cite{ConcurrentNetCore}) and our pipeline capacity theorem, such as the analysis and guarantees that such languages provide about pipeline behavior. For example, Concurrent NetCore's type system ensures that any program used to populate a pipeline has certain properties, such as determinism, whilst PISCES's switch specification allows compilers to analyze pipelines and optimize their performance. We contend, however, that our capacity theorem attacks an entirely different space in pipeline analysis - guaranteeing pipeline properties or improving performance is qualitatively different to verifying whether compilation is possible.

%\para{Multi-switch network programming:} Our pipeline capacity algebra is related to other systems that facilitate multi-switch network programming, specifically DIFANE~\cite{DIFANE} and TableVisor~\cite{TableVisor}. These systems, however, focus on distributing a centrally specified flow table/flow table pipeline across a given network, whilst our algebra verifies that generic high level language programs can be written to it.

\para{Pipeline design:} Pipeline design schemes such as Jose et al.'s ``Compiling Packet Programs to Reconfigurable Switches''~\cite{Jose-et-al}, Sun et al.'s ``Software-Defined Flow Table Pipeline''~\cite{Sun-et-al}, FlowAdapter~\cite{FlowAdapter}, and Domino~\cite{Domino} are clearly related to our pipeline capacity theorem in that they examine pipeline layout design under hardware constraints. Jose et al., Sun et al., and FlowAdapter  however, focus on mapping logical lookup tables/flow table pipelines to physical tables whilst our pipeline capacity theorem focuses on generic programs, while Domino considers weaker hardware constraints (\eg\ limits on stateful operations at line-rate) than our work does. Some other pipeline datapath design work (\eg\ \cite{Pan2017FlowConvertor}, \cite{Wang2017P4FPGA}, \cite{patra2018towards}, \cite{shahpcube}, \cite{da2017data}, \cite{pontarelli2017smashing}) focus more on the datapath configuration rather than the connection between high-level language and low-level datapath.
